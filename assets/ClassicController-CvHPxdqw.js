var L=Object.defineProperty;var F=(e,t,s)=>t in e?L(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var n=(e,t,s)=>F(e,typeof t!="symbol"?t+"":t,s);import{g as k}from"./index-D9BONVqI.js";class o{constructor(t=0,s=0){this.x=t,this.y=s}unpack(){return[this.x,this.y]}mul(t){return new o(this.x*t,this.y*t)}add(t){return new o(this.x+t.x,this.y+t.y)}sub(t){return new o(this.x-t.x,this.y-t.y)}clone(){return new o(this.x,this.y)}equals(t){return this.x===t.x&&this.y===t.y}static get up(){return new o(0,-1)}static get down(){return new o(0,1)}static get left(){return new o(-1,0)}static get right(){return new o(1,0)}}const f=class f{constructor(){n(this,"frametimes",new Array(f.maxSample));n(this,"fps",0)}update(t){this.frametimes.push(t),this.frametimes.length>f.maxSample&&this.frametimes.shift(),this.fps=1e3/this.avgFrametime}get avgFrametime(){return this.frametimes.reduce((t,s)=>t+s,0)/this.frametimes.length}draw(t){t.fillStyle="black",t.fillRect(0,0,40,20),t.fillStyle="white",t.font="bold 15px Roboto",t.fillText(this.fps.toFixed(0),5,15)}};n(f,"maxSample",100);let b=f;class y{constructor(t=0,s=0,i=0,r=1){n(this,"r");n(this,"g");n(this,"b");n(this,"a");this.r=t,this.g=s,this.b=i,this.a=r}alpha(t){return new y(this.r,this.g,this.b,t)}toString(){return`rgba(${[this.r,this.g,this.b,this.a].join(",")})`}}const M=/^rgba\(\s*(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\s*,\s*(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\s*,\s*(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\s*,\s*(0|1|0?\.\d+)\s*\)$/;class T{constructor(t){n(this,"color");this.position=t,this.color=new y(0,0,0).toString()}getColor(){return this.color}setColor(t){if(!M.test(t)){console.error(`Could not set food color, invalid color. (${t})`);return}this.color=t}setPosition(t){this.position.x=t.x,this.position.y=t.y}}const D={ArrowUp:o.up,w:o.up,W:o.up,z:o.up,Z:o.up,ArrowDown:o.down,s:o.down,S:o.down,ArrowLeft:o.left,a:o.left,A:o.left,q:o.left,Q:o.left,ArrowRight:o.right,d:o.right,D:o.right};class R{constructor(t){n(this,"direction");n(this,"body");n(this,"headColor");n(this,"bodyColor");n(this,"moveIntvl");n(this,"lastMoveTime");n(this,"inputQueue");n(this,"inputListenerFn");const s=new y(4,129,81);this.headColor=s.toString(),this.bodyColor=s.alpha(.5).toString(),this.inputQueue=[],this.moveIntvl=130,this.lastMoveTime=0,this.direction=new o(0,0),this.body=[],this.body.push(new o(t.x,t.y)),this.inputListenerFn=this.inputListener.bind(this)}canMove(){return this.lastMoveTime>=this.moveIntvl}move(){this.body.unshift(this.head.add(this.direction)),this.body.pop(),this.lastMoveTime=0}grow(){const t=this.body.at(-1);this.body.push(t.sub(this.direction))}handleDirection(){const t=this.dequeueDirection();t&&!t.equals(this.direction.mul(-1))&&(this.direction.x=t.x,this.direction.y=t.y)}get head(){return this.body[0]}update(t){this.lastMoveTime+=t,this.canMove()&&(this.handleDirection(),this.move())}didBiteIself(){const t=this.head;for(let s=1;s<this.body.length;s++){const i=this.body[s];if(t.equals(i))return!0}return!1}keyToDirection(t){return D[t]??null}dequeueDirection(){for(;this.inputQueue.length>0;){const t=this.inputQueue.shift();if(t&&!t.equals(this.direction)&&!t.equals(this.direction.mul(-1)))return t}return null}inputListener(t){const s=this.keyToDirection(t.key);s&&this.inputQueue.push(s)}removeListeners(){window.removeEventListener("keydown",this.inputListenerFn)}setupListeners(){this.removeListeners(),window.addEventListener("keydown",this.inputListenerFn)}}const E=(e,t)=>Math.abs(e.x-t.x)+Math.abs(e.y-t.y),v=(e,t,s)=>e.x<0||e.y<0||e.x>=t||e.y>=s,C=({x:e,y:t})=>[{x:e+1,y:t},{x:e-1,y:t},{x:e,y:t+1},{x:e,y:t-1}],I=(e,t,s,i)=>{let r=0;for(const l of C(t))(v(l,s,i)||e[l.y][l.x]!==0)&&r++;return r},q=(e,t,s,i,r=100)=>{const l=new Set,u=[t];let d=0;for(;u.length&&d<r;){const{x:h,y:a}=u.shift(),w=`${h},${a}`;if(!l.has(w)){l.add(w),d++;for(const c of C({x:h,y:a})){const g=`${c.x},${c.y}`;!v(c,s,i)&&e[c.y][c.x]===0&&!l.has(g)&&u.push(c)}}}return d},A=(e,t,s,i)=>{const r=t[0],l=[];for(let h=0;h<i;h++)for(let a=0;a<s;a++)e[h][a]===0&&l.push({x:a,y:h});let u=-1/0,d=[];for(const h of l){const a=E(r,h),w=q(e,h,s,i,20),c=I(e,h,s,i),g=t.length,m=-a*(g<10?10:3)+w*5-c*10;m>u?(u=m,d=[h]):m===u&&d.push(h)}return d[Math.floor(Math.random()*d.length)]},S=(e,t)=>(e=Math.ceil(e),t=Math.floor(t),Math.floor(Math.random()*(t-e))+e),p=class p{constructor(t){n(this,"perfM");n(this,"cols");n(this,"rows");n(this,"cellW");n(this,"cellH");n(this,"snake");n(this,"ctx");n(this,"maxFoodSpawn");n(this,"foods");this.canvas=t,this.cols=Math.floor(t.width/p.TARGET_CELL_SIZE),this.rows=Math.floor(t.height/p.TARGET_CELL_SIZE),this.cellW=t.width/this.cols,this.cellH=t.height/this.rows,this.perfM=new b;const[s,i]=[S(0,this.cols),S(0,this.rows)];this.snake=new R({x:s,y:i}),this.foods=[],this.maxFoodSpawn=1,this.setupCanvasRenderingContext2D()}didChomp(){const t=this.foods.findIndex(({position:s})=>s.equals(this.snake.head));return t!==-1?(this.foods.splice(t,1),!0):!1}spawnFood(t){const s=new T(new o(t.x,t.y));s.setColor(this.snake.headColor),this.foods.push(s)}spawnFoods(){const t=Array.from({length:this.rows},()=>Array(this.cols).fill(0));for(const s of this.snake.body)v(s,this.cols,this.rows)||(t[s.y][s.x]=1);for(const s of this.foods){const i=s.position;t[i.y][i.x]=1}for(let s=0;s<=this.maxFoodSpawn-this.foods.length;s++){const i=A(t,this.snake.body,this.cols,this.rows);t[i.y][i.x]=1,this.spawnFood(i)}}drawFoods(t){for(const s of this.foods){t.fillStyle=s.getColor();const i=s.position;t.fillRect(i.x*this.cellW,i.y*this.cellH,this.cellW,this.cellH)}}drawSnake(t){const s=this.snake.head;t.fillStyle=this.snake.headColor,t.beginPath(),t.rect(s.x*this.cellW,s.y*this.cellH,this.cellW,this.cellH),t.fill(),t.fillStyle=this.snake.bodyColor,t.beginPath();for(let i=1;i<this.snake.body.length;i++){const r=this.snake.body[i];t.rect(r.x*this.cellW,r.y*this.cellH,this.cellW,this.cellH)}t.fill()}drawGrid(t){t.strokeStyle="#e0e0e0",t.beginPath();for(let s=0;s<=this.cols;s++){const i=s*this.cellW;t.moveTo(i,0),t.lineTo(i,this.rows*this.cellH)}for(let s=0;s<=this.rows;s++){const i=s*this.cellH;t.moveTo(0,i),t.lineTo(this.cols*this.cellW,i)}t.stroke()}setupCanvasRenderingContext2D(){const t=this.canvas.getContext("2d");if(!t)throw new Error("Could not get CanvasRenderingContext2D !");this.ctx=t}};n(p,"TARGET_CELL_SIZE",30);let x=p;class $ extends x{constructor(t){super(t),this.canvas=t,console.log(this.cols,this.rows),this.spawnFoods()}update(t){this.snake.update(t),this.perfM.update(t),this.snake.didBiteIself()&&(k.isGameOver=!0),this.didChomp()&&(k.score+=1,this.spawnFoods(),this.snake.grow())}render(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawFoods(this.ctx),this.drawSnake(this.ctx)}setupListeners(){this.snake.setupListeners()}removeListeners(){this.snake.removeListeners()}}export{$ as default};
